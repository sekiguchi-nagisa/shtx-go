#!/usr/bin/env arsh

# Copyright (C) 2022-2024 Nagisa Sekiguchi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# +++++ public configuration variables (starts with SHTX_) ++++++

# if true, use current shtx-go binary
var SHTX_DEV_MODE = (checkenv SHTX_DEV_MODE)

var SHTX_CRASH_DUMP = $false

let SHTX_VERSION = "0.7.2"

# +++++ helper functions +++++

var SHTX_GO_BIN_PATH = ""

__shtx_error() : Nothing {
    echo 2>&1 $@
    throw new Error($@.join(" "))
}

__shtx_detect_bin() {
    let suffix = ($OSTYPE == 'cygwin' || $OSTYPE == 'msys') ? ".exe" : ""
    let ostype = $suffix.empty() ? $OSTYPE : "windows"
    if $SHTX_DEV_MODE {
        let bin_path = "$SCRIPT_DIR/shtx-go$suffix"
        if !(test -x $bin_path) {
            # rebuild
            command -v go &>> /dev/null || __shtx_error "require go binary"
            (cd $SCRIPT_DIR && command go build &>> /dev/null) | true
            test -x $bin_path || __shtx_error cannot build shtx-go
        }
        $SHTX_GO_BIN_PATH = $bin_path
    } else {
        $SHTX_GO_BIN_PATH = "$SCRIPT_DIR/shtx-go-$SHTX_VERSION-$ostype-$MACHTYPE$suffix"
        test -x $SHTX_GO_BIN_PATH && return 0
        $SHTX_GO_BIN_PATH = "$SCRIPT_DIR/shtx-go$suffix"
        test -x $SHTX_GO_BIN_PATH && return 0
        __shtx_error not found \`shtx-go\` executable in $SCRIPT_DIR
    }
}

function __save_crash_dump(in : String, out : String, e : Error) : Bool {
    printf -v var "crash_shtx_%(%Y-%m-%dT%H:%M:%S%z)T.log"
    var name = $reply.remove('var')!
    {
        echo '+++++  error message  +++++'
        $e.show() with 2>&1
        echo $'\n+++++  input script  +++++'
        printf "%s\n" $in
        echo $'\n+++++  output script  +++++'
        printf "%s\n" $out
    } with > $name
    echo 1>&2 "save crash dump:"
    echo 1>&2 -e "\t${$name.realpath()}"
    return $true
}

function __doubleQuote(v : String) : String {
    var ret = '"'
    for ch in $v {
        case $ch {
            '`'|'"'|'\'|'$' => $ret += '\'
        }
        $ret += $ch
    }
    $ret += '"'
    return $ret
}


# +++++ for shell variable +++++

let __VAR_ATTR_EXPORT = 0x01
let __VAR_ATTR_UNSET = 0x02
let __VAR_ATTR_BASHPID = 0x04

type _VarEntry(n: String, v: Any, a : Int?) {
    let _name = $n  # always indicate variable name
    var _value = $v
    var _attr = $a ?? 0

    assert $v is String || $v is [String?]
}

function has(attr: Int): Bool for _VarEntry {
    return ($this._attr and $attr) == $attr
}

function exported() : Bool for _VarEntry {
    return $this.has($__VAR_ATTR_EXPORT)
}

function isUnset() : Bool for _VarEntry {
    return $this.has($__VAR_ATTR_UNSET)
}

# update value, if entry indicates env, update env value
function update(value : Any) : String for _VarEntry {
    $this._attr = $this._attr and !$__VAR_ATTR_UNSET
    if let s = $value as? String {
        if let ss = $this._value as? [String?] { # assign to first element
            if $ss.empty() {
                $ss.add($s)
            } else {
                $ss[0] = $s
            }
        } else {
            $this._value = $value
            if $this.exported() {
                let old = $?
                setenv -- ${this._name}=$s
                $? = $old
            }
        }
        return $s
    } else {
        $this._value = $value
        var ss = $this._value as [String?]
        return $ss.get(0) ?? ""
    }
}

# for local variable unset
function unset() for _VarEntry {
    $this._attr = $this._attr or $__VAR_ATTR_UNSET
}

# export as environmental variable
function export() : _VarEntry for _VarEntry {
    var v = $this._value
    $this._attr = $this._attr or $__VAR_ATTR_EXPORT
    $this.update($v)
    return $this
}

# get value. if entry indicates env, get env value
function getAsStr() : String? for _VarEntry {
    if let s = $this._value as? String {
        if $this.exported() {
            var old = $?
            var ret = (getenv -- ${this._name}) ? $REPLY : $none
            $? = $old
            return $ret
        } elif $this.has($__VAR_ATTR_BASHPID) {
            return "$PID"
        } else {
            return $s
        }
    } else {
        var ss = $this._value as [String?]
        return $ss.get(0)
    }
}

function stringify(): String for _VarEntry {
    if let ss = $this._value as? [String?] {
        var ret = "("
        let size = $ss.size()
        var count = 0
        for(var i = 0; $i < $size; $i++) {
            var s = $ss[$i] ?? continue
            if $count > 0 {
                $ret += " "
            }
            $ret += "[$i]="
            $ret += $__doubleQuote($s)
            $count++
        }
        $ret += ")"
        return $ret
    } else {
        return $__doubleQuote($this.getAsStr() ?? "")
    }
}

function print(verbose : Bool) for _VarEntry {
    var value = $this.stringify()
    if $verbose {
        var attr = ''
        if $this._value is [String?] {
            $attr += 'a'
        }
        if $this.exported() {
            $attr += 'x'
        }
        $attr = $attr.ifEmpty('-')!
        if $this.has($__VAR_ATTR_BASHPID) {
            printf "declare -%s %s\n" $attr ${this._name}
        } else {
            printf "declare -%s %s=%s\n" $attr ${this._name} $value
        }
    } elif !$this.has($__VAR_ATTR_BASHPID) {
        printf "%s=%s\n" ${this._name} $value
    }
}

type _VarMap(_arg0 : String, _args : [String]) {
    var arg0 = $_arg0
    var args = $_args
    let entries : [String : _VarEntry]
    let pid = $PID
}

# get variable entry. if entry is not found, but corresponding env is found, set and return entry
function get(name : String, set : Bool?) : _VarEntry? for _VarMap {
    let s = $set ?? $true
    return $this.entries.get($name) ?? {
        if($s && { var old = $?; var r = checkenv -- $name; $? = $old; $r}) {
            var e = new _VarEntry($name, "", $__VAR_ATTR_EXPORT)
            $this.entries.put($name, $e)
            return $e
        }
        return $none
    }
}

function put(name : String, value : Any, attr: Int?) : String for _VarMap {
    if let entry = $this.get($name) {
        return $entry.update($value)
    } else {
        var e = new _VarEntry($name, $value, $attr)
        $this.entries.put($name, $e)
        return $e.getAsStr() ?? ""
    }
}

type _VarScope(_arg0 : String, _args : [String]) {
    let global = new _VarMap($_arg0, $_args)
    let locals : [_VarMap]

    $global.put("IFS", $IFS)
    $global.put("BASH", "$(command -v bash)")
    $global.put('PPID', "$PPID")
    $global.put('BASHPID', "$PID", $__VAR_ATTR_BASHPID)
}

function arg0() : String for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    return $v.arg0
}

function args() : [String] for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    return $v.args
}

function setArgs(args : [String]) for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    $v.args = $args
}

function get(name : String, use_env : Bool?) : _VarEntry? for _VarScope {
    ## first, get from local scope
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            return $e.isUnset() ? $none : $e
        }
    }
    ## if not found, get from global scope
    return $this.global.get($name, $use_env)
}

function find(name: String): _VarEntry? for _VarScope {
    return $this.get($name, $false)
}

function findAsStr(name : String) : String? for _VarScope {
    return if let entry = $this.find($name) { $entry.getAsStr(); } else { $none; }
}

function put(name : String, value : Any) : String for _VarScope {
    ## set to local if found
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            return $e.update($value)
        }
    }
    ## otherwise, set to global
    return $this.global.put($name, $value)
}

function local(name : String, value : String) for _VarScope {
    var local = $this.locals.peek()
    if let e = $local.entries.get($name) {
        $e.update($value)
    } else {
        $local.entries.put($name, new _VarEntry($name, $value))
    }
}

function remove(name : String) : _VarEntry? for _VarScope {
    ## if local found, unset (do not remove entry)
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            $e.unset()
            return $e
        }
    }
    ## otherwise, remove from global
    return $this.global.entries.remove($name)
}

function enterFunc(arg0 : String, args : [String]) for _VarScope {
    $this.locals.push(new _VarMap($arg0, $args))
}

function exitFunc() for _VarScope {
    $this.locals.pop()
}

function inFunc() : Bool for _VarScope {
    return !$this.locals.empty()
}

var _VARS = new _VarScope("bash", $@)

function _error(cmd : String, v : String) {
    echo 1>&2 ${$_VARS.arg0()}: $cmd: $v
}


# +++++ for glob/regex +++++

let _GLOB2RE_CACHE : [String: Regex]

let _GLOB2RE_TYPE_WHOLE = "whole"
let _GLOB2RE_TYPE_PARTIAL = "partial"
let _GLOB2RE_TYPE_START = "start"
let _GLOB2RE_TYPE_END = "end"

let _GLOB_META = $/[?*\[]/

function __glob_to_regex(pattern: String, type: String): Regex? {
    let old = $?
    defer { $? = $old; }
    let key = $type + "@" + $pattern
    var re = $_GLOB2RE_CACHE.get($key) ?? { # translate glob to regex
        __shtx_detect_bin
        var re = try {
            var s = "$(call $SHTX_GO_BIN_PATH --type=pattern --pattern-type=$type -c $pattern)"
            assert $? == 0
            new Regex($s)
        } catch e : RegexSyntaxError {
            $e.show()
            return $none
        }

        if $_GLOB2RE_CACHE.size() == 32 { # remove old entry
            var target = for k,_ in $_GLOB2RE_CACHE { break $k }
            $_GLOB2RE_CACHE.remove($target!)
        }
        $_GLOB2RE_CACHE.put($key, $re)
        $re
    }
    return $re
}

function __shtx_glob_match(values : [String]): Bool {
    let value = $values[0]
    let pattern = $values[1]
    if $_GLOB_META !~ $pattern {  # fast path (no glob meta)
        return $value == $pattern
    }
    var re = $__glob_to_regex($pattern, $_GLOB2RE_TYPE_WHOLE) ?? return $false
    return $re =~ $value
}

function __shtx_escape_glob_meta(pattern : String) : String {
    if $_GLOB_META !~ $pattern {
        return $pattern
    }
    var ret = ""
    let size = $pattern.size()
    for(var i = 0; $i < $size; $i++) {
        var ch = $pattern[$i]
        case $ch {
            '*' | '?' | '[' | ']' | '\' |
            '#' | '%'  # for '${a/#b/c}' '${a/%b/c}' expansion op
             => { $ret += '\'; }
        }
        $ret += $ch
    }
    return $ret
}

function __glob_replace(value: String, pattern: String, repl: String, once: Bool): String {
    var type = $_GLOB2RE_TYPE_PARTIAL
    if $once {
        if $pattern.startsWith('#') {
            $type = $_GLOB2RE_TYPE_START
            $pattern = $pattern.slice(1)
        } elif $pattern.startsWith('%') {
            $type = $_GLOB2RE_TYPE_END
            $pattern = $pattern.slice(1)
        }
    }
    var re = $__glob_to_regex($pattern, $type) ?? return ""
    return $re.replace($value, $repl, $once: $once)
}

let _REGEX_CACHE : [String: Regex]

function __shtx_regex_match(values: [String]): Bool {
    let value = $values[0]
    let pattern = $values[1]
    var re = $_REGEX_CACHE.get($pattern) ?? {
        var re = try { 
            new Regex($pattern)
        } catch e: RegexSyntaxError {
            $e.show()
            return $false
        }

        if $_REGEX_CACHE.size() == 32 { # remove old entry
            var key = for k,_ in $_REGEX_CACHE { break $k; }
            $_REGEX_CACHE.remove($key!)
        }
        $_REGEX_CACHE.put($pattern, $re)
        $re
    }
    return $re =~ $value  # FIXME: store match results as string array
}

function __shtx_escape_regex_meta(pattern: String): String {
    var ret = ""
    let size = $pattern.size()
    for(var i = 0; $i < $size; $i++) {
        var ch = $pattern[$i]
        case $ch {
            '^' | '$' | '.' | '*' | '?' | '[' | ']' | '\' => { $ret += '\'; }
        }
        $ret += $ch
    }
    return $ret
}

# +++++ for parameter expansion +++++

type _SHError : Error

function __shtx_var_get_impl(param : String, op : String, word : String) : String? {
    assert !$param.empty()

    case $param {
        '?' => { 
            if $op == ':+' || $op == '+' {
                return $word
            }
            return "$?" 
        }
        '#' => {
            if $op == ':+' || $op == '+' {
                return $word
            }
            return $_VARS.args().size() as String
        }
        '*' => {
            # FIXME: support expansion op
            var sep = $_VARS.findAsStr('IFS') ?? " "
            $sep = $sep.empty() ? "" : $sep[0]
            return $_VARS.args().join($sep)
        }
        '@' => {
            # FIXME: support expansion op
            return $_VARS.args().join(" ")
        }
        '$' => {
            if $op == ':+' || $op == '+' {
                return $word
            }
            return "$$"
        }
        $/^[0-9]+$/ => {
            var n = $param.toInt(10)!
            assert $n > -1
            if $n == 0 || $n - 1 < $_VARS.args().size() { # set 0, 1~
                var v = $n == 0 ? $_VARS.arg0() : $_VARS.args()[$n - 1]
                case $op {
                    ':-' => return $v.ifEmpty($word)
                    ':=' => return $v.ifEmpty() ?? throw new _SHError("${$_VARS.arg0()}: \$${param}: cannot assign in this way")
                    ':?' => return $v.ifEmpty() ?? throw new _SHError("${$_VARS.arg0()}: \$${param}: ${word}", 127)
                    ':+' => return !$v.empty() ? $word : ""
                    '+' => return $word
                    else => return $v
                }
            } else {    # unset (1~)
                case $op {
                    ':-' | '-' => return $word
                    ':=' | '=' => throw new _SHError("${$_VARS.arg0()}: ${param}: cannot assign in this way")
                    ':?' | '?' => throw new _SHError("${$_VARS.arg0()}: ${param}: ${word}", 127)
                    ':+' | '+' => return ""
                    else => return $none
                }
            }
        }
        else => {}
    }

    let v = if let entry = $_VARS.get($param) { $entry.getAsStr(); } else { $none; }
    case $op {
        ':-' => return ($v ?? "").ifEmpty($word)
        '-' => return $v ?? $word
        ':=' => return ($v ?? "").ifEmpty() ?? $_VARS.put($param, $word)
        '=' => return $v ?? $_VARS.put($param, $word)
        ':?' => return ($v ?? "").ifEmpty() ?? throw new _SHError("${$_VARS.arg0()}: ${param}: ${word}", 127)
        '?' => return $v ?? throw new _SHError("${$_VARS.arg0()}: ${param}: ${word}", 127)
        ':+' => return $v && !$v!.empty() ? $word : ""
        '+' => return $v ? $word : ""
        else => return $v
    }
}

function __shtx_get_var_at_impl(param: String, index: String, op: String, word: String): String {
    let i = $index == '*' ? 0 : $index.toInt()!
    let entry = $_VARS.get($param)
    var elem = $none as String?
    if $entry {
        if let e = $entry!._value as? [String?] {
            if $index == '*' {  # concat all array elememts
                var sep = $_VARS.findAsStr('IFS') ?? " "
                $sep = $sep.empty() ? "" : $sep[0]
                var tmp : [String]
                for a in $e {
                    $tmp.add($a ?? continue)
                }
                $elem = $tmp.join($sep)
            } else {
                $elem = $e.get($i)
            }
        } else {
            var e = $entry!._value as String
            if $i == 0 {
                $elem = $e
            }
        }
    }

    if !$elem {  # unset
        case $op {
            ':-' | '-' => return $word
            ':=' | '=' => {
                if $index == '*' {
                    echo 1>&2 "${$_VARS.arg0()}: ${param}[${index}]: bad array subscript"
                    return $word
                }
                return $__update_as_sparse_array($entry, $param, $i, $word)
            }
            ':?' | '?' => throw new _SHError("${$_VARS.arg0()}: ${param}[${index}]: ${word}", 127)
            else => return ""
        }
    } elif $elem!.empty() { # set but null
        case $op {
            ':-' | '+' => return $word
            ':=' => {
                if $index == '*' {
                    echo 1>&2 "${$_VARS.arg0()}: ${param}[${index}]: bad array subscript"
                    return $word
                }
                return $__update_as_sparse_array($entry, $param, $i, $word)
            }
            ':?' => throw new _SHError("${$_VARS.arg0()}: ${param}[${index}]: ${word}", 127)
            else => return ""
        }
    } else {  # set and not null
        case $op {
            ':+' | '+' => return $word
            else => return $elem!
        }
    }
}


# +++++ for (sparse) array construction +++++

function __update_as_sparse_array(entry: _VarEntry?, name: String, index: Int, value: String): String {
    var array = if let e = $entry {
        if let v = $e._value as? [String?] {
            $v
        } else {
            var v = $e._value as String
            var a = [$v as String?]
            $e.update($a)
            $a
        }
    } else {  # not found
        var a = new [String?]()
        $_VARS.put($name, $a)
        $a
    }
    $__sparse_array_set($array, $index, $value)
    return $value
}

function __sparse_array_set(array: [String?], index: Int, value: String) {
    while $index >= $array.size() {
        $array.add($none)
    }
    $array[$index] = $value
}

type _SparseArrayBuilder(n: String) {
    var last_index = 0;
    let name = $n
    let values: [String?]
}

function add(args: [String]): _SparseArrayBuilder for _SparseArrayBuilder {
    for arg in $args {
        $__sparse_array_set($this.values, $this.last_index, $arg)
        $this.last_index++
    }
    return $this
}

function at(args: [String]): _SparseArrayBuilder for _SparseArrayBuilder {
    var index = $args[0].toInt()!
    var value = $args[1]
    $__sparse_array_set($this.values, $index, $value)
    $this.last_index = $index + 1
    return $this
}

function build(): Bool for _SparseArrayBuilder {
    $_VARS.put($this.name, $this.values)
    return $true
}


# +++++ for declare/local commands +++++

let _FUNC_MAP : [String: (String, Command)]

function __printEntries(entries: [String: _VarEntry], verbose : Bool) {
    for _, e in $entries {
        $e.isUnset() && continue
        $e.print($verbose)
    }
}

function __show_vars(args: [String], local : Bool) : Int {
    var fail = $false
    (!$args.empty() && $local) && return 0
    if $local { # only show locals
        $__printEntries($_VARS.locals.peek().entries, $false)
    } elif !$args.empty() {
        for arg in $args {
            if let ret = $_VARS.find($arg) {
                if !$ret.isUnset() {
                    $ret.print($true)
                    continue
                }
            }
            $fail = $true
            $_error('declare', "$arg: not found")
        }
    } else {
        if $_VARS.inFunc() {
            $__printEntries($_VARS.locals.peek().entries, $true)
        }
        $__printEntries($_VARS.global.entries, $true)
    }
    return $fail ? 1 : 0
}

[<CLI>]
type _DeclareOpt() {
    [<Flag(short: 'F', help: "display function names")>]
    var funcDecl = $false

    [<Flag(short: 'f', help: "display function names with body")>]
    var funcBody = $false

    [<Flag(short: 'p', help: 'display the attribute and value of variable')>]
    var printVar = $false

    [<Arg()>]
    var args : [String]
}

function __shtx_define_vars(cmd: String, args: [String]) : Int {
    let local = $cmd == "local"
    let opt = new _DeclareOpt()
    $opt.setName($cmd)
    try {
        $opt.parse($args)
    } catch e : CLIError {
        echo ${$e.message()} 1>&2
        return $e.status()
    }
    if ($opt.funcDecl||$opt.funcBody) && $opt.args.empty() && !$local {
        var prefix = $opt.funcDecl ? "declare -f " : ""
        var dels : [String:Bool]?
        for name, e in $_FUNC_MAP {
            if let f = $DYNA_UDCS.get($name) {
                if $f == $e._1 {
                    printf "%s%s\n" $prefix ${$opt.funcDecl ? $name : $e._0}
                    continue
                }
            }
            ($dels ?? ({ $dels = new [String:Bool](); $dels!; })).put($name, $true)
        }
        ## remove inconsistent entry
        for k,_ in $dels {
            $_FUNC_MAP.remove($k)
        }
        return 0
    }
    if $opt.printVar {
        return $__show_vars($opt.args, $local)
    }
    var fail = $false
    for arg in $opt.args {
        $arg.empty() && continue
        let i = $arg.indexOf('=')
        let name = $i != -1 ? $arg.slice(0, $i) : $arg
        if $opt.funcDecl || $opt.funcBody {
            if $i != -1 { 
                $_error($cmd, "cannot use \`-f' option with assignment")
                return 1
            }
            if let e = $_FUNC_MAP.get($name) {
                if let f = $DYNA_UDCS.get($name) {
                    $e._1 == $f && printf "%s\n" ${$opt.funcDecl ? $name : $e._0} && continue
                }
                $_FUNC_MAP.remove($name)
            }
            $fail = $true
            continue
        }
        $name =~ $/^[a-zA-Z_][0-9a-zA-Z_]*$/ || { $_error($cmd, "$arg: not a valid identifier"); return 1; }
        let value = $i != -1 ? $arg.slice($i + 1) : ""
        $local ? $_VARS.local($name, $value) : $_VARS.put($name, $value)
    }
    return $fail ? 1 : 0
}


# +++++ runtime helper functions (starts with __shtx_) +++++

# for global varibale access
function __shtx_get_var(args: [String]): String {
    let param = $args[0]
    let op = $args.get(1) ?? ''
    let word = $args.get(2) ?? ''
    let replace = $op == '/' || $op == '//'
    var ret = $__shtx_var_get_impl($param, $replace ? "" : $op, $word)
    if $replace && $ret {
        var pattern = $word
        var repl = $args.get(3) ?? ''
        $ret = $__glob_replace($value:$ret!, $pattern:$pattern, $repl:$repl, $once:$op == '/')
    }
    return $ret ?? ""
}

function __shtx_set_var(args: [String]): Bool {
    var param = $args[0].ifEmpty() ?? return $true
    var word = $args.get(1) ?? ''
    $_VARS.put($param, $word)
    return $true
}

function __shtx_get_array_var(name: String): [String?] {
    var ret : [String?]
    if $name == "@" {
        for a in $_VARS.args() {
            $ret.add($a)
        }
    } elif let entry = $_VARS.get($name) {
        if let aa = $entry._value as? [String?] {
            return $aa
        }
        if let s = $entry.getAsStr() {
            $ret.add($s)
        }
    }
    return $ret
}

function __shtx_set_array_var(name: String, args: [String]): Bool {
    var array: [String?]
    for arg in $args {
        $array.add($arg)
    }
    $_VARS.put($name, $array)
    return $true
}

function __shtx_get_var_at(args: [String]): String {
    let param = $args[0]
    let index = $args[1]
    let op = $args.get(2) ?? ''
    let word = $args.get(3) ?? ''
    let replace = $op == '/' || $op == '//'
    var ret = $__shtx_get_var_at_impl($param, $index, $replace ? "" : $op, $word)
    if $replace {
        var pattern = $word
        var repl = $args.get(4) ?? ''
        $ret = $__glob_replace($value:$ret, $pattern:$pattern, $repl:$repl, $once:$op == '/')
    }
    return $ret
}

function __shtx_cond(v: Bool): Bool {
    $? = 0 # always clear exit status
    return $v
}

let _builtin_map = [
    '[': '__shtx_[',
    'builtin': '__shtx_builtin',
    'declare': '__shtx_declare',
    'typeset': '__shtx_typeset',
    'export': '__shtx_export',
    'local': '__shtx_local',
    'unset': '__shtx_unset',
    'shift': '__shtx_shift',
    'read': '__shtx_read',
    'printf': '__shtx_printf',
    'return': '__shtx_return',
    'trap': '__shtx_trap',
    'eval': 'fake_eval',
    '.': 'fake_source',
    'source': 'fake_source',
]

# for bash declare command
__shtx_declare() {
    return $__shtx_define_vars("declare", $@)
}

# for bash typeset command
__shtx_typeset() {
    return $__shtx_define_vars("typeset", $@)
}

# for bash local command
__shtx_local() {
    $_VARS.inFunc() || {
        $_error("local", "can only be used in a function")
        return 1;
    }
    return $__shtx_define_vars("local", $@)
}

# for bash export command
__shtx_export() {
    for arg in $@ {
        ($arg.empty() || $arg.startsWith("-")) && continue
        let i = $arg.indexOf('=')
        let name = $i != -1 ? $arg.slice(0, $i) : $arg

        ## export var as env if not found, create new entry
        let entry = $_VARS.get($name) ?? {
            $_VARS.put($name, "")
            $_VARS.get($name)!
        }
        if !$entry.exported() {
            $entry.export()
        }

        ## update env
        if $i != -1 {
            $entry.update($arg.slice($i + 1))
        }
    }
    return 0
}

# for bash unset command
__shtx_unset() {
    var opt = ""
    while !$@.empty() {
        var a = $@[0]
        if ! $a.startsWith("-") {
            break
        }
        if $a == '-f' || $a == '-v' {
            $opt = $a
            $@.shift()
        } else {
            $_error('unset', "${a}: invalid option")
            return 2
        }
    }

    var var = $true
    var func = $true
    if $opt == '-v' {
        $func = $false
    } elif $opt == '-f' {
        $var = $false
    }

    for arg in $@ {
        $arg.empty() && continue
        ## first try remove variable
        if $var {
            if let entry = $_VARS.remove($arg) {
                $entry.exported() && unsetenv -- $arg
                continue
            }
        }
        ## if variable is not found, try remove function (only remove user-defined functions)
        if $func {
            if let e = $_FUNC_MAP.remove($arg) {
                if let f = $DYNA_UDCS.get($arg) {
                    if $e._1 == $f {
                        $DYNA_UDCS.remove($arg)
                    }
                }
            }
        }
    }
    return 0
}

__shtx_shift() {
    var offset = 1
    if !$1.empty() {
        $offset = $1.toInt(10) ?? { 
            $_error("shift", "numeric argument required"); 
            return 1;
        }
    }
    ($offset < 0 || $offset > $_VARS.args().size()) && return 1

    for(var i = 0; $i < $offset; $i++) {
        $_VARS.args().shift()
    }
    return 0
}

__shtx_[() {
    ($# == 0 || $@.peek() != ']') && { $_error("[", "missing \`]'"); return 2; }
    $@.pop()    # skip last ']'
    test $@
}

__shtx_builtin() {
    $# == 0 && return 0
    if let cmd = $_builtin_map.get($1) {
        $@[0] = $cmd
        call $@
        return $?
    } elif (command -V $1 | grep 'is a shell builtin command' &>> /dev/null) {
        call $@
        return $?
    }
    $_error("builtin", "$1: not a shell builtin command");
    return 1
}

__shtx_read() {
    $reply.clear()
    let ifs = $_VARS.findAsStr('IFS') ?? $' \t\n'
    IFS=$ifs read $@
    for k, v in $reply {
        $_VARS.put($k, $v)
    }
    $_VARS.put('REPLY', $REPLY)
}

__shtx_printf() {
    $reply.clear()
    printf $@
    for k,v in $reply {
        $_VARS.put($k, $v)
    }
}

function __shtx_parse_status(s : String) : Int {
    if let r = $s.toInt(10) {
        return $r and 255
    }
    $_error("return", "numeric argument required")
    return 2
}

var _SOURCE_PIDS : [Int]

type _Return : Error

__shtx_return() {
    if !$_VARS.inFunc() && $_SOURCE_PIDS.empty() {
        $_error('return', 'only available in function or sourced script')
        return 1
    }
    var status = $@.size() > 0 ? $__shtx_parse_status($1) : $?
    if ($_VARS.inFunc() && $PID != $_VARS.locals.peek().pid) || 
        (!$_SOURCE_PIDS.empty() && $PID != $_SOURCE_PIDS.peek()) { # in subshell
        _exit $status
    }
    throw new _Return('', $status)
}

type _Context() {
    ## set runtime options
    let option = { shctl set -d; $REPLY; }
    shctl unset errraise &>> /dev/null
    shctl unset fail_tilde &>> /dev/null
    shctl unset fail_glob &>> /dev/null
    true
}

var _CALL_COUNT = 0

function __shtx_setup_context() : _Context? {
    $_CALL_COUNT++
    if $_CALL_COUNT == 1 {
        return new _Context()
    } else {
        return $none
    }
}

function __shtx_restore_context($ctx : _Context?) {
    let old = $?
    defer { $? = $old; }
    if let c = $ctx {
        shctl set -r ${c.option}
    }
    $_CALL_COUNT--
}

function __shtx_compile_eval(input: String): (()-> Void)? {
    __shtx_detect_bin

    var opt : [String]
    if $SHTX_CRASH_DUMP {
        $opt.add("--crash-dump")
    }
    var output = "$(call $SHTX_GO_BIN_PATH $opt - <<< $input)"
    if $? != 0 {
        return $none
    }
    try {
        return $MODULE._func($output)
    } catch e: Error {
        $e.show()
        $SHTX_CRASH_DUMP && $__save_crash_dump($input, $output, $e)
        $? = 255
        return $none
    }
}

function __shtx_run_eval(func: ()-> Void): Int {
    try {
        let ctx = $__shtx_setup_context()
        defer { $__shtx_restore_context($ctx); }
        $func()
        return $?
    } catch e : _SHError {
        echo 1>&2 ${$e.message()}
        return $e.status()
    }
}


[<CLI>]
type _TrapParam() {
    [<Flag(short: 'l', help: 'list supported signals', stop: $true)>]
    var list = $false

    [<Flag(short: 'p', help: 'print signal handlers', stop: $true)>]
    var print = $false

    [<Arg>]
    var args : [String]
}

let _TRAP : [Signal : (String, (() -> Void)?)]
let _OLD_TRAP : [Signal : (Signal)-> Void]

function __shtx_signal_handler(s: Signal) {
    if let func = $_TRAP.get($s) {
        $__shtx_run_eval($func._1 ?? return)
    }
}

__shtx_trap() {
    let param : _TrapParam
    try {
        $param.setName('trap')
        $param.parse($@)
    } catch e: CLIError {
        echo 1>&2 ${$e.message()}
        return $e.status()
    }

    if $param.list {
        kill -l
        return 0
    }
    if $param.print {
        if $param.args.empty() {
            var values : [(Signal, String)]
            for k, v in $_TRAP {
                $values.add(($k, $v._0))
            }
            $values.sortWith(function(x,y) => $x._0.value() < $y._0.value())
            for value in $values {
                printf "trap -- %s SIG%s\n" $__doubleQuote($value._1) ${$value._0.name()}
            }
            return 0
        } else {  # print specifed signal setting
            var errors = 0
            for arg in $param.args {
                var sig = $SIG.get($arg) ?? {
                    $_error('trap', "${arg}: invalid signal specification")
                    $errors++
                    continue
                }
                if let v = $_TRAP.get($sig) {
                    printf "trap -- %s SIG%s\n" $__doubleQuote($v._0) ${$sig.name()}
                }
            }
            return $errors == 0 ? 0 : 1
        }
    }
    $param.args.empty() && return 0
    if $param.args.size() < 2 {
        echo 1>&2 ${$param.usage()}
        return 2
    }
    let action = $param.args.shift()
    var func : (()->Void)?
    if !$action.empty() && $action != '-' {
        $func = $__shtx_compile_eval($action) ?? return $?
    }
    var errors = 0
    for arg in $param.args {
        var sig = $SIG.get($arg) ?? {
            $_error('trap', "${arg}: invalid signal specification")
            $errors++
            continue
        }
        if $action == '' {  # ignore signal
            $_TRAP[$sig] = ($action, $func)
            var old = $sig.trap($SIG_IGN)
            $_OLD_TRAP.putIfAbsent($sig, $old)
        } elif $action == '-' { # reset signal
            if let old = $_OLD_TRAP.remove($sig) {  # reset if has old hanlder
                $_TRAP.remove($sig)
                $sig.trap($old)
            }
        } else { # set handler
            $_TRAP[$sig] = ($action, $func)
            var old = $sig.trap($__shtx_signal_handler)
            $_OLD_TRAP.putIfAbsent($sig, $old)
        }
    }
    return $errors == 0 ? 0 : 1
}

function __shtx_set_argv(argv : [String]) : [String] {
    var old : [String]
    $old.add($_VARS.arg0())
    $old.addAll($_VARS.args())
    ## FIXME: update arg0 ?
    $_VARS.setArgs($argv.slice(1))
    return $old
}

function __shtx_cnf(cmd: String, argv: [String]): Bool {
    if let obj = $DYNA_UDCS.get('command_not_found_handle') {
        $argv.unshift('command_not_found')
        return $obj.call($argv)
    }
    if $_CALL_COUNT == 0 {
        echo 1>&2 $cmd: command not found
    } else { # within translated code
        $_error($cmd, "command not found")
    }
    $? = 127
    return $false
}
source $MODULE_DIR/cnf.arsh as _cnf
$_cnf.CNF_HOOK = $__shtx_cnf

function __shtx_func(name : String, src: String, cmd : Command) : Bool {
    $DYNA_UDCS[$name] = $cmd
    if $name == 'command_not_found_handle' {
        $_cnf.CNF_HOOK = $__shtx_cnf
    }
    $_FUNC_MAP[$name] = ($src, $cmd)
    return $true
}

function __shtx_enter_func(arg0 : String, args : [String]) : _Context? {
    $_VARS.enterFunc("bash", $args)  # FIXME: set arg0 ?
    return $__shtx_setup_context()
}

function __shtx_exit_func(ctx : _Context?) {
    $_VARS.exitFunc()
    $__shtx_restore_context($ctx)
}

function __shtx_concat(values : [Any]) : [String] {
    var ret : [String]
    if !$values.empty() {
        $ret.add("")
    }
    for value in $values {
        if let s = $value as? String {
            var r = $ret.pop()
            $r += $s
            $ret.push($r)
        } elif let aa = $value as? [String?] {
            var count = 0
            for a in $aa {
                var v = $a ?? continue
                if $count == 0 {
                    var r = $ret.pop()
                    $r += $v
                    $ret.push($r)
                } else {
                    $ret.push($v)
                }
                $count++
            }
        }
    }
    return $ret
}

let _EVAL_CODE_CACHE : [String : ()->Void]

function __shtx_eval_with_cache(input : String) : Int {
    var func = $_EVAL_CODE_CACHE.get($input)
    if !$func {  # translate and compile code
        $func = $__shtx_compile_eval($input)
        if $_EVAL_CODE_CACHE.size() == 8 {
            var k = for k,_ in $_EVAL_CODE_CACHE { break $k}!
            $_EVAL_CODE_CACHE.remove($k)
        }
        $_EVAL_CODE_CACHE.put($input, $func!)
    }
    return $__shtx_run_eval($func!)
}

source $MODULE_DIR/repl_impl/prompt as __prompt
$__prompt.PRE_PROMPTS.add(function() => {
    let entry = $_VARS.find('PROMPT_COMMAND') ?? return
    if let array = $entry._value as? [String?] {
        for a in $array {
            var cmd = $a ?? continue
            $cmd.ifEmpty() ?? continue
            $__shtx_eval_with_cache($cmd)
        }
    } else {
        var prompt_cmd = $entry.getAsStr() ?? ""
        $prompt_cmd.ifEmpty() ?? return
        $__shtx_eval_with_cache($prompt_cmd)
    }
})

source $MODULE_DIR/atexit.arsh

let TEMP_FILES : [String]
{
    let hd = function() => {
        for e in $TEMP_FILES {
            rm -f $e || true
        }
        $TEMP_FILES.clear()
    }
    let f = $atexit as Any
    if let _atexit = $f as? ((Int, Any) -> Void, Int?) -> Void {
        $_atexit(function(s,a) => $hd())  ## for old api
    } elif let _atexit = $f as? (() -> Void) -> Void {
        $_atexit($hd)  ## for new api
    }
}

function __save_to_temp(path: String): String? {
    (test -f $path || test -d $path) && return $none
    var tmp = "$(mktemp 2>>/dev/null)"
    test -f $tmp || return $none
    $TEMP_FILES.add($tmp)
    try {
        for line in $STDIN {
            printf "%s\n" $line
        } with < $path > $tmp
        return $tmp
    } catch e {
        return $none
    }
}

# +++++ public api functions (starts with fake_) +++++

# evaluate bash script (emulate bash eval command)
fake_eval() {
    $@.empty() && return 0
    return $__shtx_run_eval($__shtx_compile_eval($@.join(' ')) ?? return $?)
}

source $MODULE_DIR/completion as __comp

# evaluate bash script (emulate bash source command)
fake_source() {
    $@.empty() && {
        $_error("source", "filename argument required")
        return 2
    }

    __shtx_detect_bin

    var input = $@[0]
    $input = $__save_to_temp($input) ?? $input
    if $input.contains("completion") || $@[0] != $input {  # may be completion script
        if let target = try { $__comp.extractCompTarget($input); } catch e: SystemError{ $none; } {
            __comp compdef --cmd ${target._1} --comp-path $input --comp-target ${target._0} && return 0
        }
    }

    var opt = ['--type=source']
    if $SHTX_CRASH_DUMP {
        $opt.add("--crash-dump")
    }
    var output = "$(call $SHTX_GO_BIN_PATH $opt -- $input)"
    if $? != 0 {
        return 1
    }
    try {
        let ctx = $__shtx_setup_context()
        $_SOURCE_PIDS.push($PID)
        defer { $__shtx_restore_context($ctx); $_SOURCE_PIDS.pop(); }
        var func = $MODULE._func($output)()! as ([String]) -> Int
        return $func($@)
    } catch e : _SHError {
        echo 1>&2 ${$e.message()}
        return $e.status()
    } catch e : Error {
        $e.show()
        var lines = ""
        for line in new FD($input) {
            $lines += $line
            $lines += $'\n'
        }
        $SHTX_CRASH_DUMP && $__save_crash_dump($lines, $output, $e)
        return 255
    }
}

fake_call() {
    $@.empty() && return 0

    ## not call internal api (__shtx_ or fake_)
    if $@[0].startsWith("__shtx_") || $@[0].startsWith("fake_") {
        if let cmd = $DYNA_UDCS.get($@[0]) {
            $cmd.call($@)
        } else {
            command $@
        }
        return $?
    }
    var cmd = $@[0]
    $@[0] = $_builtin_map.get($cmd) ?? $cmd
    call $@
 }

# +++++ entry point for cli +++++

[<CLI(toplevel: $true)>]
type _Param() {
    [<Option(short: "c", stop: $true, help: "execute command")>]
    var cmd : String?

    [<Flag(help: "enable crash dump (disabled by default)")>]
    var crash_dump = $false

    [<Flag(short: "v", long: "version", stop: $true, help: "show version")>]
    var version = $false

    [<Arg>]
    var args : [String]
}

__shtx_main(param : _Param) {
    if $param.version {
        echo $SHTX_VERSION
        return 0
    }
    $SHTX_CRASH_DUMP = $param.crash_dump
    if let input = $param.cmd { # -c cmd
        $__shtx_set_argv($param.args)
        fake_eval $input
    } elif !$param.args.empty() { # script
        var script = $param.args.shift()
        fake_source $script ${param.args}
    } else {
        echo ${$param.usage("need script")} 1>&2
        return 1
    }
}

shctl is-sourced || __shtx_main $@
