#!/usr/bin/env ydsh

# Copyright (C) 2022-2023 Nagisa Sekiguchi
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# +++++ public configuration variables (starts with SHTX_) ++++++

# if true, use current shtx-go binary
var SHTX_DEV_MODE = $false

var SHTX_CRASH_DUMP = $true

let SHTX_VERSION = "0.0.0"

# +++++ helper functions +++++

var _SHTX_GO_BIN_PATH = ""

_error() : Nothing {
    echo 2>&1 $@
    throw new Error($@.join(" "))
}

_detect_bin() {
    let suffix = ($OSTYPE == 'cygwin' || $OSTYPE == 'msys') ? ".exe" : ""
    let ostype = $suffix.empty() ? $OSTYPE : "windows"
    if $SHTX_DEV_MODE || (checkenv SHTX_DEV_MODE) {
        command -v go &>> /dev/null || _error "require go binary"
        if !(test -x $SCRIPT_DIR/shtx-go$suffix) {
            # rebuild
            (cd $SCRIPT_DIR && command go build &>> /dev/null) | true
            test -x $SCRIPT_DIR/shtx-go$suffix || _error cannot build shtx-go
        }
        $_SHTX_GO_BIN_PATH = "$SCRIPT_DIR/shtx-go"
    } else {
        $_SHTX_GO_BIN_PATH = "$SCRIPT_DIR/shtx-go-$SHTX_VERSION-$ostype-$MACHTYPE$suffix"
        test -x $_SHTX_GO_BIN_PATH && return 0
        $_SHTX_GO_BIN_PATH = "$SCRIPT_DIR/shtx-go$suffix"
        test -x $_SHTX_GO_BIN_PATH && return 0
        _error not found \`shtx-go\` executable in $SCRIPT_DIR
    }
}

function __save_crash_dump(in : String, out : String, e : Error) : Bool {
    printf -v var "crash_shtx_%(%Y-%m-%dT%H:%M:%S%z)T.log"
    var name = $reply.remove('var')!
    {
        echo '+++++  error message  +++++'
        $e.show() with 2>&1
        echo $'\n+++++  input script  +++++'
        echo $in
        echo $'\n+++++  output script  +++++'
        echo $out
    } with > $name
    echo 1>&2 "save crash dump:"
    echo 1>&2 -e "\t${$name.realpath()}"
    return $true
}


# +++++ for shell variable +++++

let __VAR_ATTR_EXPORT = 0x01
let __VAR_ATTR_UNSET = 0x02
let __VAR_ATTR_IFS = 0x04

typedef _VarEntry(v: String?, a : Int?) {
    var _value = $v ?? ""  # if indicate env, value is env name
    var _attr = $a ?? 0
}

function exported() : Bool for _VarEntry {
    return ($this._attr and $__VAR_ATTR_EXPORT) == $__VAR_ATTR_EXPORT
}

function isUnset() : Bool for _VarEntry {
    return ($this._attr and $__VAR_ATTR_UNSET) == $__VAR_ATTR_UNSET
}

function ifs() : Bool for _VarEntry {
    return ($this._attr and $__VAR_ATTR_IFS) == $__VAR_ATTR_IFS
}

# update value, if entry indicates env, update env value
function set(value : String) : String for _VarEntry {
    if $this.exported() {
        setenv -- ${this._value}=$value
    } else {
        $this._value = $value
    }
    if $this.ifs() {    # sync IFS
        $IFS = $value
    }
    $this._attr = $this._attr and !$__VAR_ATTR_UNSET
    return $value
}

# for local variable unset
function unset() for _VarEntry {
    $this._attr = $this._attr or $__VAR_ATTR_UNSET
}

# export as environmental variable
function export(name : String) : _VarEntry for _VarEntry {
    var v = $this._value
    $this._attr = $this._attr or $__VAR_ATTR_EXPORT
    $this._value = $name
    $this.set($v)
    return $this
}

# get value. if entry indicates env, get env value
function _get_impl() : String? for _VarEntry {
    if $this.exported() {
        return (getenv -- ${this._value}) ? $REPLY : $none
    } else {
        return $this._value
    }
}

function get() : String? for _VarEntry {
    var r = $this._get_impl()
    if $this.ifs() {
        if !$r || $r! != $IFS {
            $this.set($IFS)  # sync IFS
            $r = $IFS
        }
    }
    return $r
}

typedef _VarMap(_arg0 : String, _args : [String]) {
    var arg0 = $_arg0
    var args = $_args
    let entries : [String : _VarEntry]
}

# get variable entry. if entry is not found, but corresponding env is found, set and return entry
function get(name : String) : _VarEntry? for _VarMap {
    return $this.entries.get($name) ?? {
        if(checkenv -- $name) {
            var e = new _VarEntry($name, $__VAR_ATTR_EXPORT)
            $this.entries.put($name, $e)
            return $e
        }
        return $none
    }
}

function put(name : String, value : String) : String for _VarMap {
    if let entry = $this.get($name) {
        $entry.set($value)
    } else {
        let ifs = $name == 'IFS'
        if $ifs && $value != $IFS {
            $IFS = $value
        }
        $this.entries.put($name, new _VarEntry($value, $ifs ? $__VAR_ATTR_IFS : $none))
    }
    return $value
}

typedef _VarScope(_arg0 : String, _args : [String]) {
    let global = new _VarMap($_arg0, $_args)
    let locals : [_VarMap]

    $global.put("IFS", $IFS)
}

function arg0() : String for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    return $v.arg0
}

function args() : [String] for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    return $v.args
}

function setArgs(args : [String]) for _VarScope {
    var v = $this.locals.empty() ? $this.global : $this.locals.peek()
    $v.args = $args
}

function get(name : String) : _VarEntry? for _VarScope {
    ## first, get from local scope
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            return $e.isUnset() ? $none : $e
        }
    }
    ## if not found, get from global scope
    return $this.global.get($name)
}

function put(name : String, value : String) : String for _VarScope {
    ## set to local if found
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            return $e.set($value)
        }
    }
    ## otherwise, set to global
    return $this.global.put($name, $value)
}

function local(name : String, value : String) for _VarScope {
    var local = $this.locals.peek()
    if let e = $local.entries.get($name) {
        $e.set($value)
    } else {
        $local.entries.put($name, new _VarEntry($value))
    }
}

function remove(name : String) : _VarEntry? for _VarScope {
    ## if local found, unset (do not remove entry)
    if !$this.locals.empty() {
        var local = $this.locals.peek()
        if let e = $local.entries.get($name) {
            $e.unset()
            return $e
        }
    }
    ## otherwise, remove from global
    return $this.global.entries.remove($name)
}

function enterFunc(arg0 : String, args : [String]) for _VarScope {
    $this.locals.push(new _VarMap($arg0, $args))
}

function exitFunc() for _VarScope {
    $this.locals.pop()
}

function inFunc() : Bool for _VarScope {
    return !$this.locals.empty()
}

var _VARS = new _VarScope("bash", $@)

function _error(cmd : String, v : String) {
    echo 1>&2 ${$_VARS.arg0()}: $cmd: $v
}

function __shtx_cmd_fallback(m : Module, argv : [String]) : Bool {
    $_error($argv[0], "command not found")
    $? = 127
    return $false
}

typedef _SHError : Error

function __shtx_var_get_impl(param : String, op : String, word : String) : String {
    assert !$param.empty()

    case $param {
        '?' => { 
            if $op == ':+' || $op == '+' {
                return $word
            }
            return "$?" 
        }
        '#' => {
            if $op == ':+' || $op == '+' {
                return $word
            }
            return $_VARS.args().size() as String
        }
        '*' => {
            # FIXME: support expansion op
            let ifs = if let entry = $_VARS.get('IFS') { $entry.get(); } else { $none; }
            var sep = ($ifs ?? " ")
            $sep = $sep.empty() ? "" : $sep[0]
            return $_VARS.args().join($sep)
        }
        $/^[0-9]+$/ => {
            var n = $param.toInt(10)!
            assert $n > -1
            if $n == 0 || $n - 1 < $_VARS.args().size() { # set 0, 1~
                var v = $n == 0 ? $_VARS.arg0() : $_VARS.args()[$n - 1]
                case $op {
                    ':-' => return $v :- $word
                    ':=' => return $v :- throw new _SHError("${$_VARS.arg0()}: \$${param}: cannot assign in this way")
                    ':?' => return $v :- throw new _SHError("${$_VARS.arg0()}: \$${param}: ${word}", 127)
                    ':+' => return !$v.empty() ? $word : ""
                    '+' => return $word
                    else => return $v :- ""
                }
            } else {    # unset (1~)
                case $op {
                    ':-' | '-' => return $word
                    ':=' | '=' => throw new _SHError("${$_VARS.arg0()}: \$${param}: cannot assign in this way")
                    ':?' | '?' => throw new _SHError("${$_VARS.arg0()}: \$${param}: ${word}", 127)
                    ':+' | '+' => return ""
                    else => return ""
                }
            }
        }
        else => {}
    }

    let v = if let entry = $_VARS.get($param) { $entry.get(); } else { $none; }
    case $op {
        ':-' => return ($v ?? "") :- $word
        '-' => return $v ?? $word
        ':=' => return ($v ?? "") :- $_VARS.put($param, $word)
        '=' => return $v ?? $_VARS.put($param, $word)
        ':?' => return ($v ?? "") :- throw new _SHError("${$_VARS.arg0()}: \$${param}: ${word}", 127)
        '?' => return $v ?? throw new _SHError("${$_VARS.arg0()}: \$${param}: ${word}", 127)
        ':+' => return $v && !$v!.empty() ? $word : ""
        '+' => return $v ? $word : ""
        else => return $v ?? ""
    }
}

# +++++ runtime helper functions (starts with __shtx_) +++++

# for global varibale access
__shtx_var_get() {
    # __shtx_var_get $? $param $op $word
    var old = $1.toInt()!
    var param = $2
    var op = $3
    var word = $4
    $? = $old
    $REPLY = $__shtx_var_get_impl($param, $op, $word)
    return $old
}

__shtx_var_set() {
    var param = $1 :- return 0
    var word = $2
    $_VARS.put($param, $word)
    return 0
}

# for bash local command
__shtx_local() {
    $_VARS.inFunc() || {
        $_error("local", "can only be used in a function")
        return 1;
    }

    for arg in $@ {
        ($arg.empty() || $arg.startsWith("-")) && continue
        let i = $arg.indexOf('=')
        let name = $i != -1 ? $arg.slice(0, $i) : $arg
        let value = $i != -1 ? $arg.slice($i + 1) : ""
        $_VARS.local($name, $value)
    }
}

# for bash export command
__shtx_export() {
    for arg in $@ {
        ($arg.empty() || $arg.startsWith("-")) && continue
        let i = $arg.indexOf('=')
        let name = $i != -1 ? $arg.slice(0, $i) : $arg

        ## export var as env if not found, create new entry
        let entry = $_VARS.get($name) ?? {
            $_VARS.put($name, "")
            $_VARS.get($name)!
        }
        if !$entry.exported() {
            $entry.export($name)
        }

        ## update env
        if $i != -1 {
            $entry.set($arg.slice($i + 1))
        }
    }
    return 0
}

# for bash unset command
__shtx_unset() {
    var opt = ""
    while !$@.empty() {
        var a = $@[0]
        if ! $a.startsWith("-") {
            break
        }
        if $a == '-f' || $a == '-v' {
            $opt = $a
            $@.shift()
        } else {
            $_error('unset', "${a}: invalid option")
            return 2
        }
    }

    var var = $true
    var func = $true
    if $opt == '-v' {
        $func = $false
    } elif $opt == '-f' {
        $var = $false
    }

    for arg in $@ {
        $arg.empty() && continue
        ## first try remove variable
        if $var {
            if let entry = $_VARS.remove($arg) {
                $entry.exported() && unsetenv -- $arg
                if $entry.ifs() {
                    $IFS = $' \t\n' # reset to default
                }
                continue
            }
        }
        ## if variable is not found, try remove function (only remove user-defined functions)
        if $func {
            $DYNA_UDCS.remove($arg)
        }
    }
    return 0
}

__shtx_shift() {
    var offset = 1
    if !$1.empty() {
        $offset = $1.toInt(10) ?? { 
            $_error("shift", "numeric argument required"); 
            return 1;
        }
    }
    ($offset < 0 || $offset > $_VARS.args().size()) && return 1

    for(var i = 0; $i < $offset; $i++) {
        $_VARS.args().shift()
    }
    return 0
}

__shtx_[() {
    ($# == 0 || $@.peek() != ']') && { $_error("[", "missing \`]'"); return 2; }
    $@.pop()    # skip last ']'
    test $@
}

__shtx_read() {
    $reply.clear()
    read $@
    for k, v in $reply {
        __shtx_var_set $k $v
    }
}

__shtx_printf() {
    $reply.clear()
    printf $@
    for k,v in $reply {
        __shtx_var_set $k $v
    }
}


# dynamically resolve command name
__shtx_dyna_call() {
    $@.empty() && return 0

    var cmd = $@.shift()
    $cmd = case $cmd {
        '[' => '__shtx_['
        'export' => '__shtx_export'
        'local' => '__shtx_local'
        'unset' => '__shtx_unset'
        'shift' => '__shtx_shift'
        'read' => '__shtx_read'
        'printf' => '__shtx_printf'
        'eval' => 'fake_eval'
        '.' | 'source' => 'fake_source'
        else => $cmd
    }
    call $cmd $@
}

function __shtx_set_argv(argv : [String]) : [String] {
    var old : [String]
    $old.add($_VARS.arg0())
    $old.addAll($_VARS.args())
    ## FIXME: update arg0 ?
    $_VARS.setArgs($argv.slice(1))
    return $old
}

function __shtx_get_args() : [String] {
    return $_VARS.args()
}

function __shtx_func(name : String, cmd : Command) : Bool {
    $DYNA_UDCS[$name] = $cmd
    return $true
}

function __shtx_enter_func(arg0 : String, args : [String]) {
    $_VARS.enterFunc("bash", $args)  # FIXME: set arg0 ?
}

function __shtx_exit_func() {
    $_VARS.exitFunc()
}

function __shtx_concat(values : [Any]) : [String] {
    var ret : [String]
    if !$values.empty() {
        $ret.add("")
    }
    for value in $values {
        if let s = $value as? String {
            var r = $ret.pop()
            $r += $s
            $ret.push($r)
        } elif let aa = $value as? [String] {
            let size = $aa.size()
            for(var i = 0; $i < $size; $i++) {
                if $i == 0 {
                    var r = $ret.pop()
                    $r += $aa[$i]
                    $ret.push($r)
                } else {
                    $ret.push($aa[$i])
                }
            }
        }
    }
    return $ret
}


# +++++ public api functions (starts with fake_) +++++

# evaluate bash script (emulate bash eval command)
fake_eval() {
    $@.empty() && return 0

    _detect_bin

    var input = $@.join(" ")
    var opt : [String]
    if $SHTX_CRASH_DUMP {
        $opt.add("--crash-dump")
    }
    var output = "$(call $_SHTX_GO_BIN_PATH $opt - <<< $input)"
    if $? != 0 {
        return 1
    }
    try {
        let old = $CMD_FALLBACK
        $CMD_FALLBACK = $__shtx_cmd_fallback
        defer { $CMD_FALLBACK = $old; }
        $MODULE._func($output)()
    } catch e : _SHError {
        return $e.status()
    } catch e : Error {
        $e.show()
        $SHTX_CRASH_DUMP && $__save_crash_dump($input, $output, $e)
        return 255
    }
}

source $MODULE_DIR/completion as __comp

# evaluate bash script (emulate bash source command)
fake_source() {
    $@.empty() && {
        $_error("source", "filename argument required")
        return 2
    }

    _detect_bin

    var input = $@[0]
    if $input.contains("completion") {  # may be completion script
        if let target = $__comp.extractCompTarget($input) {
            __comp compdef --cmd ${target._1} --comp-path $input --comp-target ${target._0} && return 0
        }
    }

    var opt = ['--type=source']
    if $SHTX_CRASH_DUMP {
        $opt.add("--crash-dump")
    }
    var output = "$(call $_SHTX_GO_BIN_PATH $opt $input)"
    if $? != 0 {
        return 1
    }
    try {
        let old = $CMD_FALLBACK
        $CMD_FALLBACK = $__shtx_cmd_fallback
        defer { $CMD_FALLBACK = $old; }
        var func = $MODULE._func($output)()! as ([String]) -> Void
        $func($@)
    } catch e : _SHError {
        return $e.status()
    } catch e : Error {
        $e.show()
        $SHTX_CRASH_DUMP && $__save_crash_dump($input, $output, $e)
        return 255
    }
}


# +++++ entry point for cli +++++

[<CLI(toplevel: $true)>]
typedef _Param() {
    [<Option(short: "c", stop: $true, help: "execute command")>]
    var cmd : String?

    [<Arg>]
    var args : [String]
}

_main(param : _Param) {
    if let input = $param.cmd { # -c cmd
        $__shtx_set_argv($param.args)
        fake_eval $input
    } elif !$param.args.empty() { # script
        var script = $param.args.shift()
        fake_source $script ${param.args}
    } else {
        echo ${$param.usage("need script")} 1>&2
        return 1
    }
}

shctl is-sourced || _main $@
